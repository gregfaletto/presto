remotes::install_github("jacobbien/litr-project", subdir = "litr")
rm(list=ls())
rmarkdown::draft("create-rhello.Rmd", template = "make-an-r-package", package = "litr")
rmarkdown::draft("create-rhello.Rmd", template = "make-an-r-package", package = "litr")
?case_when
library(tidyverse)
p <- c(4/16, 3/16, 2/16, 1/16, 3/16, 2/16, 1/16)
sum(p)
x <- c(0:3, -1:-3)
x
x %*% p
(x - 0)^2 %*% p
sqrt((x - 0)^2 %*% p)
2.5*16
500*1/2400 + 4*4/2400 + 10*10/2400
library(MASS)
fractions(500*1/2400 + 4*4/2400 + 10*10/2400)
77*8
x <- c(500, 4, 10, 0)
p <- c(1/2400, 4/2400, 10/2400, 2385/2400)
sum(p)
(x - 77/300)^2 %*% p
sqrt((x - 77/300)^2 %*% p)
x %*% p
77/300*5
x <- c(-1000, 0, 1000, 2000, 3000)
p <- c(0.13, 0.15, .24, 0.35, 0.13)
x %*% p
sum(p)
(1 - .45)^10
1 - (1 - .45)^10 - 10*.45*(1 - .45)^9
?binomcdf
?rbinom
pbinom(q=5, size=10, prob=0.45)
pbinom(q=0, size=10, prob=0.45)
pbinom(q=1, size=10, prob=0.45)
(1 - .45)^10 + 10*.45*(1 - .45)^9
dbinom(x=3, size=5, prob=0.25)
qnorm(p=0.7, mean=125, sd=6.5)
1 - .7^5 - 5*.3*.7^4
?rgeom
(1 - .19)^4*.19
1/.19
1 - pgeom(10, .19)
4*.6^3*.4 + .6^4
15*.6
sqrt(15*.6*.4)
5400+3070+2200-1720
5400+3070+2200-1720-6033
81346 - 75323
564-69
library(cssr)
data <- genClusteredData(n = 200, # Sample size
p = 100, # Number of features
cluster_size = 10, # Number of features in a cluster correlated with a latent variable
k_unclustered = 10, # Number of unclustered features that influence y
snr = 3 # Signal-to-noise ratio in the response y generated from the data.
)
X <- data$X
y <- data$y
output <- cssSelect(X, y)
rm(list=ls())
data <- genClusteredData(n = 80, # Sample size
p = 40, # Number of features
cluster_size = 10, # Number of features in a cluster correlated with a latent variable
k_unclustered = 10, # Number of unclustered features that influence y
snr = 3 # Signal-to-noise ratio in the response y generated from the data.
)
X <- data$X
y <- data$y
output <- cssSelect(X, y)
output <- cssSelect(X, y)
output$selected_feats
clus_output <- cssSelect(X, y, clusters=list("Z_cluster"=1:10))
clus_output <- cssSelect(X, y, clusters=list("Z_cluster"=1:10))
clus_output$selected_feats
clus_output$selected_clusts
clusters <- list("Z_clust"=1:10, 50:55)
# Wrapper functions (easy!)
n_test <- 50
n <- 200
p <- 100
testx <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
cssPredict(X, y, testx, clusters)
clusters <- list("Z_clust"=1:10, 36:40)
# Wrapper functions (easy!)
n_test <- 50
n <- 80
p <- 40
testx <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
# cssPredict(X, y, testx, clusters)
cssPredict(X, y, testx, clusters)
n_test <- 50
n <- 200
p <- 40
testx <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
cssPredict(X, y, testx, clusters)
inds <- 1:round(n/2)
lambda <- getLassoLambda(X[setdiff(1:n, inds), ], y[setdiff(1:n, inds)])
lambda <- getLassoLambda(X, y)
lambda
results <- css(X=X, y=y, lambda=lambda
, clusters=clusters
# , clusters=list()
# , clusters=1:10
# , sampling.type = "SS"
# B = 100,
# , prop_feats_remove = .5
, train_inds = inds
)
inds <- 1:round(n/2)
results <- css(X=X, y=y, lambda=lambda
, clusters=clusters
# , clusters=list()
# , clusters=1:10
# , sampling.type = "SS"
# B = 100,
# , prop_feats_remove = .5
, train_inds = inds
)
nrow(X)
n
inds <- 1:40
results <- css(X=X, y=y, lambda=lambda
, clusters=clusters
# , clusters=list()
# , clusters=1:10
# , sampling.type = "SS"
# B = 100,
# , prop_feats_remove = .5
, train_inds = inds
)
str(results)
predictions <- results |> getCssPreds(testX = testx, weighting="sparse",
cutoff=0.3
, min_num_clusts=1
, max_num_clusts=3
)
predictions
train_x <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
train_y <- rnorm(n_test)
preds2 <- results |> getCssPreds(testX = testx, weighting=w,
cutoff=c, min_num_clusts=1, max_num_clusts=3,
trainX=train_x
, trainY=train_y
)
preds2 <- results |> getCssPreds(testX = testx, weighting="sparse",
cutoff=0.3, min_num_clusts=1, max_num_clusts=3,
trainX=train_x
, trainY=train_y)
preds2
selections <- results |> getCssSelections(weighting=w, cutoff=c
# , min_num_clusts=1
# , max_num_clusts=3
)
selections <- results |> getCssSelections(weighting="sparse", cutoff=0.3
# , min_num_clusts=1
# , max_num_clusts=3
)
str(selections)
selections$selected_clusts
selections$selected_feats
results |> print.cssr(cutoff=c, min_num_clusts=1, max_num_clusts=3)
print(results)
print(results, cutoff=0.3, max_num_clusts=5)
x_design <- results |> getCssDesign(testx, weighting=w, cutoff=c, min_num_clusts=1, max_num_clusts=3)
x_design <- results |> getCssDesign(testx, weighting="weighted_avg", cutoff=0.3,
min_num_clusts=1, max_num_clusts=3)
str(x_design)
rm(list=ls())
data <- genClusteredData(n = 80, # Sample size
p = 40, # Number of features
cluster_size = 10, # Number of features in a cluster correlated with a latent variable
k_unclustered = 10, # Number of unclustered features that influence y
snr = 3 # Signal-to-noise ratio in the response y generated from the data.
)
X <- data$X
y <- data$y
output <- cssSelect(X, y)
output$selected_feats
library(cssr)
data <- genClusteredData(n = 80, # Sample size
p = 40, # Number of features
cluster_size = 10, # Number of features in a cluster correlated with a latent variable
k_unclustered = 10, # Number of unclustered features that influence y
snr = 3 # Signal-to-noise ratio in the response y generated from the data.
)
X <- data$X
y <- data$y
output <- cssSelect(X, y)
output$selected_feats
clus_output <- cssSelect(X, y, clusters=list("Z_cluster"=1:10))
clus_output$selected_feats
clus_output$selected_clusts
clusters <- list("Z_clust"=1:10, 36:40)
# Wrapper functions (easy!)
n_test <- 50
n <- 80
p <- 40
testx <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
cssPredict(X, y, testx, clusters)
# Get a good lambda
lambda <- getLassoLambda(X, y)
# clusters <- list(1:10, 46:40)
# clusters <- 1:10
inds <- 1:40
results <- css(X=X, y=y, lambda=lambda
, clusters=clusters
# , clusters=list()
# , clusters=1:10
# , sampling.type = "SS"
# B = 100,
# , prop_feats_remove = .5
, train_inds = inds
)
str(results)
predictions <- results |> getCssPreds(testX = testx, weighting="sparse",
cutoff=0.3
, min_num_clusts=1
, max_num_clusts=3
)
predictions
train_x <- matrix(rnorm(n_test*p), nrow=n_test, ncol=p)
train_y <- rnorm(n_test)
preds2 <- results |> getCssPreds(testX = testx, weighting="sparse",
cutoff=0.3, min_num_clusts=1, max_num_clusts=3,
trainX=train_x
, trainY=train_y)
preds2
selections <- results |> getCssSelections(weighting="sparse", cutoff=0.3
# , min_num_clusts=1
# , max_num_clusts=3
)
str(selections)
selections$selected_clusts
selections$selected_feats
print(results, cutoff=0.3, max_num_clusts=5)
x_design <- results |> getCssDesign(testx, weighting="weighted_avg", cutoff=0.3,
min_num_clusts=1, max_num_clusts=3)
str(x_design)
?rowMeans
x_design
rowMeans(x_design)
str(x_design)
str(rowMeans(x_design))
?setdiff
remotes::install_github("jacobbien/litr-project", subdir = "litr",force=TRUE)
4*81
2*3^4
162*2
1750/5000
runif(1)
runif(1)
outer(rep(2, 5), rep(2, 5))
T <- 5
omega <- function(s, c){
return(diag(rep(s, T)) + matrix(rep(c, T*T), T, T))
}
omega(5, 2)
omega_inv <- function(s, c){
return(1/s*(diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)))
}
omega_inv(5, 2)
omega(5, 2) %*% omega_inv(5, 2)
omega_inv <- function(s, c){
return(1/s*(- matrix(-c/(s + T*c), T, T)))
}
omega_inv(5, 2)
omega <- function(s, c){
return(diag(rep(s, T)) + matrix(rep(c, T*T), T, T))
}
omega_inv <- function(s, c){
return(1/s*(diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)) )
}
omega(5, 2)
omega_inv(5,2)
diag(rep(1, T)) - matrix(-c/(s + T*c), T, T))
diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
c <- 2
5 <- s
s <- 5
diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
omega <- function(s, c){
return(diag(rep(s, T)) + matrix(rep(c, T*T), T, T))
}
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
return(1/s*ret)
}
omega_inv(5, 2)
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
print("intermediate:")
print(ret)
return(1/s*ret)
}
omega_inv(5, 2)
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
return(1/s*ret)
}
omega(5, 2) %*% omega_inv(5, 2)
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(-s*c/(1 + T*c), T, T)
return(1/s*ret)
}
omega(5, 2) %*% omega_inv(5, 2)
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(-c/(s + T*c), T, T)
return(1/s*ret)
}
omega(5, 2) %*% omega_inv(5, 2)
outer(rep(2, 5), rep(2, 5))
rep(2, 5) %*% rep(2, 5)
omega_inv <- function(s, c){
ret <- diag(rep(1, T)) - matrix(c/(s + T*c), T, T)
return(1/s*ret)
}
omega(5, 2) %*% omega_inv(5, 2)
omega(5, 8) %*% omega_inv(5, 8)
1980.77*2
420/12
69/12
2/3*sqrt(2*.981)*.25 - .25
1/1.7*sqrt(2*.981)*.25 - .25
2/3*sqrt(2*9.81)*.25 - .25
553019/60/60/24
1 + 3.75
6.25v - (1 + 3.75)
6.25 - (1 + 3.75)
6.25 - (.5 + 3.75)
4.5 + 4.25 + 6.25
.5*-99 _ 1644
.5*-99 + 1644
.5*-75 + 2793
2755.5/60/60
1594.5/60/60
4*exp(5)
2*exp(5 + log(2))
2.5*215
8*45+118
2.5*210
library(tidyverse)
library(epipredict)
jhu <- case_death_rate_subset
jhu
canned <- arx_forecaster(epi_data=jhu, outcome="death_rate", predictors=c("case_rate", "death_rate"))
str(canned)
summary(canned)
canned
n <- 100
x <- rnorm(100)
y <- 0.01*x + rnorm(100, sd=sqrt(5))
df <- data.frame(x=x, y=y)
ggplot(df, aes(x=x, y=y)) + geom_point()
n <- 100
x <- rnorm(100)
y <- 0.01*x + rnorm(100, sd=sqrt(2))
df <- data.frame(x=x, y=y)
ggplot(df, aes(x=x, y=y)) + geom_point()
n <- 100
x <- rnorm(100)
y <- 0.1*x + rnorm(100, sd=sqrt(2))
df <- data.frame(x=x, y=y)
ggplot(df, aes(x=x, y=y)) + geom_point()
setwd("/Users/gregfaletto/Documents/GitHub/did/simulations")
source("did_sims.R")
setwd("/Users/gregfaletto/Documents/GitHub/did/simulations")
source("did_sims.R")
?colMeans
source("did_sims.R")
source("did_sims.R")
source("did_sims.R")
p
N <- 120
T <- 30
R
d <- 12
num_treats <- R*T - R*(R + 1)/2
num_treats
R + T - 1 + d*(1 + R + T - 1) + (d + 1)*num_treats
N*T
stargazer(cohort_att_coverage_results, summary=FALSE)
library(stargazer)
install.packages("stargazer")
library(stargazer)
stargazer(cohort_att_coverage_results, summary=FALSE)
stargazer(cohort_att_p_values, summary=FALSE)
stargazer(att_mse_res$mean_se_df, summary=FALSE)
stargazer(att_mse_res$p_values, summary=FALSE)
stargazer(att_mse_cov_res$mean_se_df, summary=FALSE)
stargazer(att_mse_cov_res$p_values, summary=FALSE)
stargazer(att_conf_width_res$mean_se_df, summary=FALSE)
stargazer(att_conf_width_res$p_values, summary=FALSE)
mse_df
cohort_mse_res <- cohortResults(methods, n_sims, n_cores, R, e,
metric="cohort_mses")
cohort_mse_results <- cohort_mse_res$cohort_att_coverage_results
cohort_mse_p_values <- cohort_mse_res$cohort_att_p_values
rm(cohort_res)
print("MSE table for cohorts:")
print(cohort_mse_results)
print("p-values:")
print(cohort_mse_p_values)
?t.test
cohortResults <- function(methods, n_sims, n_cores, R, e,
metric="cohort_att_coverage", alternative="greater"){
n_methods <- length(methods)
# cohort_mse_mat <- array(as.numeric(NA), dim=c(n_methods, n_sims*n_cores, R))
cohort_att_coverage_mat <- array(as.numeric(NA), dim=c(n_methods,
n_sims*n_cores, R))
dimnames(cohort_att_coverage_mat)[[1]] <- methods
for(i in 1:(n_cores*n_sims)){
df_inds_i <- ((i - 1)*R*n_methods + 1):(i*R*n_methods)
stopifnot(length(df_inds_i) == R*n_methods)
for(m in 1:n_methods){
if(methods[m] == "etwfe"){
if(all(is.na(e@evals[[methods[m]]][[i]]$cohort_mses))){
next
}
}
stopifnot(length(e@evals[[methods[m]]][[i]][[metric]]) == R)
cohort_att_coverage_mat[m, i, ] <-
e@evals[[methods[m]]][[i]][[metric]]
}
}
# stopifnot(all(!is.na(cohort_att_coverage_mat)))
cohort_att_coverage_df <- matrix(as.numeric(NA), nrow=R, ncol=n_methods)
cohort_att_coverage_sd_df <- matrix(as.numeric(NA), nrow=R, ncol=n_methods)
colnames(cohort_att_coverage_df) <- methods
rownames(cohort_att_coverage_df) <- paste("Cohort", 2:(R + 1))
colnames(cohort_att_coverage_sd_df) <- methods
rownames(cohort_att_coverage_sd_df) <- paste("Cohort", 2:(R + 1))
for(m in 1:n_methods){
cohort_att_coverage_mat_m <- as.matrix(cohort_att_coverage_mat[m, , ])
stopifnot(ncol(cohort_att_coverage_mat_m) == R)
cohort_att_coverage_df[, m] <- colMeans(cohort_att_coverage_mat_m,
na.rm=TRUE)
for(r in 1:R){
cohort_att_coverage_sd_df[r, m] <- sd(cohort_att_coverage_mat_m[,
r], na.rm=TRUE)
}
# print(methods[m])
# print(colMeans(cohort_att_coverage_mat_m))
}
# stopifnot(all(!is.na(cohort_att_coverage_df)))
# stopifnot(all(!is.na(cohort_att_coverage_sd_df)))
cohort_att_coverage_results <- matrix(as.character(), nrow=R,
ncol=n_methods)
cohort_att_p_values <- matrix(as.character(), nrow=R, ncol=n_methods - 1)
colnames(cohort_att_coverage_results) <- methods
rownames(cohort_att_coverage_results) <- paste("Cohort", 2:(R + 1))
competitors <- methods[methods != "fetwfe"]
stopifnot(length(competitors) == n_methods  - 1)
colnames(cohort_att_p_values) <- competitors
rownames(cohort_att_p_values) <- paste("Cohort", 2:(R + 1))
for(m in 1:n_methods){
for(r in 1:R){
cov_r_m <- cohort_att_coverage_df[r, m]
cov_sd_r_m <- cohort_att_coverage_sd_df[r, m]/sqrt(n_sims*n_cores)
cohort_att_coverage_results[r, m] <- paste(round(cov_r_m, 3), " (",
round(cov_sd_r_m, 3), ")", sep="")
}
}
for(m in 1:(n_methods - 1)){
for(r in 1:R){
p_values_r_m <- t.test(x=cohort_att_coverage_mat["fetwfe", , r],
y=cohort_att_coverage_mat[competitors[m], , r],
alternative=alternative, paired=TRUE, var.equal=FALSE,
na.action=na.omit)$p.value
cohort_att_p_values[r, m] <-as.character(signif(p_values_r_m,
digits=3))
}
}
return(list(cohort_att_coverage_results=cohort_att_coverage_results,
cohort_att_p_values=cohort_att_p_values))
}
cohort_mse_res <- cohortResults(methods, n_sims, n_cores, R, e,
metric="cohort_mses", alternative="less")
cohort_mse_results <- cohort_mse_res$cohort_att_coverage_results
cohort_mse_p_values <- cohort_mse_res$cohort_att_p_values
rm(cohort_res)
print("MSE table for cohorts:")
print(cohort_mse_results)
print("p-values:")
print(cohort_mse_p_values)
stargazer(cohort_mse_results, summary=FALSE)
stargazer(cohort_mse_p_values, summary=FALSE)
source("did_sims.R")
source("did_sims.R")
sd(e_df[e_df$Method == meth, "att_coverage"],
na.rm=TRUE)
sd(e_df[e_df$Method == meth, "att_coverage"],
na.rm=TRUE)/sqrt(N*T)
sd(e_df[e_df$Method == meth, "att_coverage"],
na.rm=TRUE)/sqrt(1500*15)
setwd("/Users/gregfaletto/Documents/GitHub/presto")
source("4_1_sparse_diffs.R")
source("4_1_sparse_diffs.R")
install.packages("cowplot")
source("4_1_sparse_diffs.R")
create_plots(sparse_sim)
res <- create_plots(sparse_sim)
res$main_plot
?plot_grid
setwd(dir_code)
source("model_functions.R")
source("method_functions.R")
source("eval_functions.R")
source("sim_eval_function.R")
setwd(dir_main)
create_plots(sparse_sim)
