stopifnot(p >= nblocks*block_size)
stopifnot(n_strong_block_vars <= block_size)
# start with p x p identity matrix
Sigma <- var*diag(p)
# create matrix with nblocks rows, each containing a vector of
# indices of highly correlated features
block_feats <- matrix(seq(nblocks*block_size), nrow=nblocks, byrow=TRUE)
stopifnot(length(unique(block_feats)) == length(block_feats))
# add covariances of highly correlated features to sigma
for(i in 1:nblocks){
for(j in 1:(block_size - 1)){
for(k in (j+1):block_size){
feat_1 <- block_feats[i, j]
feat_2 <- block_feats[i, k]
Sigma[feat_1, feat_2] <- rho_low
Sigma[feat_2, feat_1] <- rho_low
}
}
for(j in 1:(n_strong_block_vars - 1)){
for(k in (j+1):n_strong_block_vars){
feat_1 <- block_feats[i, j]
feat_2 <- block_feats[i, k]
Sigma[feat_1, feat_2] <- rho_high
Sigma[feat_2, feat_1] <- rho_high
}
}
}
stopifnot(is.numeric(Sigma))
stopifnot(is.matrix(Sigma))
stopifnot(nrow(Sigma) == p & ncol(Sigma) == p)
stopifnot(all(Sigma == t(Sigma)))
return(Sigma)
}
makeCovarianceMatrixWeighted(p=8, nblocks=1, block_size=5, n_strong_block_vars=2, rho_high=0.9, rho_low=0.5, var=1)
eigen(makeCovarianceMatrixWeighted(p=8, nblocks=1, block_size=5, n_strong_block_vars=2, rho_high=0.9, rho_low=0.5, var=1))$values
2*3^4
library(MASS)
.5*1/6*(1/4)^2
fractions(.5*1/6*(1/4)^2)
library(cssr)
citation("cssr")
categories1 <- c("dog", "cat", "lamb", "cow", "cow")
n <- length(categories1)
cats <- unqique(categories1)
cats <- unique(categories1)
cats
which(cats == array[1])
which(cats == categories1[1])
categories1[1]
getMat <- function(array){
# Get categories
cats <- unique(array)
n <- length(array)
p <- length(pats)
ret <- matrix(0, n, p)
colnames(ret) <- cats
for(i in 1:n){
# Identify the index I want to fill
ind_i <- which(cats ==array[i])
ret[i, ind_i] <- 1
}
stopifnot(all(rowSums(ret) == 1))
return(ret)
}
getMat(categories1)
getMat <- function(array){
# Get categories
cats <- unique(array)
n <- length(array)
p <- length(cats)
ret <- matrix(0, n, p)
colnames(ret) <- cats
for(i in 1:n){
# Identify the index I want to fill
ind_i <- which(cats ==array[i])
ret[i, ind_i] <- 1
}
stopifnot(all(rowSums(ret) == 1))
return(ret)
}
getMat(categories1)
categories1
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
splits
?tolower
splits <- tolower(splits)
splits
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits[[i]] <- tolower(splits[[i]])
}
splits
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits_i <- tolower(splits[[i]])
# Go one word at a time and change first letter to upper-case
splits_i_lets <- strsplit(splits_i, split="", fixed=TRUE)
# Upper case the first letter
splits_i_lets[1] <- toupper(splits_i_lets[1])
# Collapse back together
splits[[i]] <- paste(splits_i_lets, collapse="")
}
splits
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits_i <- tolower(splits[[i]])
print("splits_i:")
print(splits_i)
# Go one word at a time and change first letter to upper-case
splits_i_lets <- strsplit(splits_i, split="", fixed=TRUE)
print("splits_i_lets:")
print(splits_i_lets)
# Upper case the first letter
splits_i_lets[1] <- toupper(splits_i_lets[1])
print("splits_i_lets:")
print(splits_i_lets)
# Collapse back together
splits[[i]] <- paste(splits_i_lets, collapse="")
print("splits[[i]]:")
print(splits[[i]])
}
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits_i <- tolower(splits[[i]])
print("splits_i:")
print(splits_i)
# Go one word at a time and change first letter to upper-case
splits_i_lets <- strsplit(splits_i, split="", fixed=TRUE)[[1]]
print("splits_i_lets:")
print(splits_i_lets)
# Upper case the first letter
splits_i_lets[1] <- toupper(splits_i_lets[1])
print("splits_i_lets:")
print(splits_i_lets)
# Collapse back together
splits[[i]] <- paste(splits_i_lets, collapse="")
print("splits[[i]]:")
print(splits[[i]])
}
splits
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:1){
splits_i <- tolower(splits[[i]])
print("splits_i:")
print(splits_i)
# Go one word at a time and change first letter to upper-case
splits_i_lets <- strsplit(splits_i, split="", fixed=TRUE)[[1]]
print("splits_i_lets:")
print(splits_i_lets)
# Upper case the first letter
splits_i_lets[1] <- toupper(splits_i_lets[1])
print("splits_i_lets:")
print(splits_i_lets)
# Collapse back together
splits[[i]] <- paste(splits_i_lets, collapse="")
print("splits[[i]]:")
print(splits[[i]])
}
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:1){
splits_i <- tolower(splits[[i]])
print("splits_i:")
print(splits_i)
n_words <- length(splits_i)
for(j in 1:n_words){
# Go one word at a time and change first letter to upper-case
splits_ij_lets <- strsplit(splits_i[j], split="", fixed=TRUE)[[1]]
print("splits_ij_lets:")
print(splits_ij_lets)
# Upper case the first letter
splits_ij_lets[1] <- toupper(splits_ij_lets[1])
print("splits_ij_lets:")
print(splits_ij_lets)
# Replace this word in splits_i
splits_i <- paste(splits_ij_lets, collapse="")
print("splits_i:")
print(splits_i)
}
# Collapse back together
splits[[i]] <- paste(splits_i, collapse=" ")
print("splits[[i]]:")
print(splits[[i]])
}
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:1){
splits_i <- tolower(splits[[i]])
print("1")
print("splits_i:")
print(splits_i)
n_words <- length(splits_i)
for(j in 1:n_words){
# Go one word at a time and change first letter to upper-case
splits_ij_lets <- strsplit(splits_i[j], split="", fixed=TRUE)[[1]]
print("2")
print("splits_ij_lets:")
print(splits_ij_lets)
# Upper case the first letter
splits_ij_lets[1] <- toupper(splits_ij_lets[1])
print("3")
print("splits_ij_lets:")
print(splits_ij_lets)
# Replace this word in splits_i
splits_i <- paste(splits_ij_lets, collapse="")
print("4")
print("splits_i:")
print(splits_i)
}
# Collapse back together
splits[[i]] <- paste(splits_i, collapse=" ")
print("splits[[i]]:")
print(splits[[i]])
}
n_words
split_i
splits_i
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:1){
splits_i <- tolower(splits[[i]])
print("1")
print("splits_i:")
print(splits_i)
n_words <- length(splits_i)
for(j in 1:n_words){
# Go one word at a time and change first letter to upper-case
splits_ij_lets <- strsplit(splits_i[j], split="", fixed=TRUE)[[1]]
print("2")
print("splits_ij_lets:")
print(splits_ij_lets)
# Upper case the first letter
splits_ij_lets[1] <- toupper(splits_ij_lets[1])
print("3")
print("splits_ij_lets:")
print(splits_ij_lets)
# Replace this word in splits_i
splits_i[j] <- paste(splits_ij_lets, collapse="")
print("4")
print("splits_i:")
print(splits_i)
}
# Collapse back together
splits[[i]] <- paste(splits_i, collapse=" ")
print("splits[[i]]:")
print(splits[[i]])
}
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits_i <- tolower(splits[[i]])
# print("1")
# print("splits_i:")
# print(splits_i)
n_words <- length(splits_i)
for(j in 1:n_words){
# Go one word at a time and change first letter to upper-case
splits_ij_lets <- strsplit(splits_i[j], split="", fixed=TRUE)[[1]]
# print("2")
# print("splits_ij_lets:")
# print(splits_ij_lets)
# Upper case the first letter
splits_ij_lets[1] <- toupper(splits_ij_lets[1])
# print("3")
# print("splits_ij_lets:")
# print(splits_ij_lets)
# Replace this word in splits_i
splits_i[j] <- paste(splits_ij_lets, collapse="")
# print("4")
# print("splits_i:")
# print(splits_i)
}
# Collapse back together
splits[[i]] <- paste(splits_i, collapse=" ")
# print("splits[[i]]:")
# print(splits[[i]])
}
splits
test <- c("This is pascal case", "DS is fun", "thisoNe hAs some typos")
splits <- strsplit(test, split=" ", fixed=TRUE)
n <- length(splits)
for(i in 1:n){
splits_i <- tolower(splits[[i]])
# print("1")
# print("splits_i:")
# print(splits_i)
n_words <- length(splits_i)
for(j in 1:n_words){
# Go one word at a time and change first letter to upper-case
splits_ij_lets <- strsplit(splits_i[j], split="", fixed=TRUE)[[1]]
# print("2")
# print("splits_ij_lets:")
# print(splits_ij_lets)
# Upper case the first letter
splits_ij_lets[1] <- toupper(splits_ij_lets[1])
# print("3")
# print("splits_ij_lets:")
# print(splits_ij_lets)
# Replace this word in splits_i
splits_i[j] <- paste(splits_ij_lets, collapse="")
# print("4")
# print("splits_i:")
# print(splits_i)
}
# Collapse back together
splits[[i]] <- paste(splits_i, collapse="")
# print("splits[[i]]:")
# print(splits[[i]])
}
splits
n <- 10
# random uniform
probs <- runif(n)
y_true <- rbinom(n=n, size=1, prob=0.5)
probs
y_true
n <- 10
# random uniform
probs <- runif(n)
y_true <- rbinom(n=n, size=1, prob=0.5)
# Numerator: classified as being in class 1 and are in class 1
# denominator: classified as being in class 1
denom_count <- sum(probs > 0.5)
num_count <- sum((probs > 0.5) & (y_true == 1))
precision <- num_count/denom_count
precision
probs
y_true
denom_count
?sample
set.seed(23541)
n <- 10
p <- 3
X <- matrix(runif(n*p, min=1, max=10), n, p)
beta <- c(0.6, 2.5, 1.3)
y <- X %*% beta + rnorm(n)
X
y
# Start by setting objective function
obj_func <- function(beta_hat){
resids <- y - X %*% beta_hat
return(sum(resids^2))
}
obj_func(rep(0, 3))
obj_func(beta_hat=beta)
gradGreg <- function(beta_hat, x_i, y_i){
resid <- x_i %*% beta_hat - y_i
return(2*x_i*resid)
}
gradGreg(rep(0, p), X[1, ], y[1])
gradGreg <- function(beta_hat, x_i, y_i){
print("x_i:")
print(x_i)
print("x_i %*% beta_hat:")
print(x_i %*% beta_hat)
resid <- x_i %*% beta_hat - y_i
return(2*x_i*resid)
}
gradGreg(rep(0, p), X[1, ], y[1])
gradGreg <- function(beta_hat, x_i, y_i){
print("x_i:")
print(x_i)
print("x_i %*% beta_hat:")
print(x_i %*% beta_hat)
resid <- as.numeric(x_i %*% beta_hat) - y_i
return(2*x_i*resid)
}
gradGreg <- function(beta_hat, x_i, y_i){
# print("x_i:")
# print(x_i)
# print("x_i %*% beta_hat:")
# print(x_i %*% beta_hat)
resid <- as.numeric(x_i %*% beta_hat) - y_i
return(2*x_i*resid)
}
gradGreg(rep(0, p), X[1, ], y[1])
gradGreg(beta, X[1, ], y[1])
sample(1:n, size=1)
# Stochastic gradient descent
solveStoch <- function(X, y, init, lr = 0.0001, n_iterations = 10000){
n <- nrow(X)
stopifnot(n == length(y))
beta_hat <- init
for(i in 1:n_iterations){
# Choose a random observation
ind_i <- sample(1:n, size=1)
# Update taking a small step in gradient direction
gradient_i <- gradGreg(beta_hat=beta_hat, x_i=X[ind_i, ], y_i=y[ind_i])
beta_hat <- beta_hat - lr*gradient_i
}
return(beta_hat)
}
solveStoch(X, y, rep(0, p))
beta
library(simulator)
simulate_func <- function(x, nsim){
ret_list <- list()
for(i in 1:nsim){
ret_list[[i]] <- 1
}
return(ret_list)
}
error_sim_model <- function(x){
my_model <- new_model(name = "error_sim_model",
label = "err_model",
params = list(x=x),
simulate = simulate_func
)
return(my_model)
}
bad_meth <- new_method("bad_meth", "Bad method",
method = function(model, draw) {
if(as.logical(rbinom(n=1, size=1, prob=0.5))){
return(list(a=2))
} else{
return(list(b=3))
}
return(ret)
}
)
sim <- new_simulation("sim", "Error sim")
sim <- generate_model(sim, error_sim_model, x=2)
sim <- generate_model(sim, error_sim_model, x=2)
sim <- simulate_from_model(sim, nsim = 20)
sim <- run_method(sim, list(bad_meth))
library(simulator)
simulate_func <- function(x, nsim){
ret_list <- list()
for(i in 1:nsim){
ret_list[[i]] <- 1
}
return(ret_list)
}
error_sim_model <- function(x){
my_model <- new_model(name = "error_sim_model",
label = "err_model",
params = list(x=x),
simulate = simulate_func
)
return(my_model)
}
bad_meth <- new_method("bad_meth", "Bad method",
method = function(model, draw) {
if(as.logical(rbinom(n=1, size=1, prob=0.5))){
return(list(a=2))
} else{
return(list(b=3))
}
return(ret)
}
)
sim <- new_simulation("sim", "Error sim")
sim <- generate_model(sim, error_sim_model, x=2)
sim <- simulate_from_model(sim, nsim = 20)
sim <- run_method(sim, list(bad_meth))
library(simulator)
set.seed(12375)
simulate_func <- function(x, nsim){
ret_list <- list()
for(i in 1:nsim){
ret_list[[i]] <- 1
}
return(ret_list)
}
error_sim_model <- function(x){
my_model <- new_model(name = "error_sim_model",
label = "err_model",
params = list(x=x),
simulate = simulate_func
)
return(my_model)
}
bad_meth <- new_method("bad_meth", "Bad method",
method = function(model, draw) {
if(as.logical(rbinom(n=1, size=1, prob=0.5))){
return(list(a=2))
} else{
return(list(b=3))
}
return(ret)
}
)
sim <- new_simulation("sim", "Error sim")
sim <- generate_model(sim, error_sim_model, x=2)
sim <- simulate_from_model(sim, nsim = 20)
sim <- run_method(sim, list(bad_meth))
setwd("/Users/gregfaletto/Documents/GitHub/presto")
source("4_1_sparse_diffs.R")
fig_2
fig_1
fig_5
fig_6
fig_7
ret$t_d_df
ret$summary_df
setwd("/Users/gregfaletto/Documents/GitHub/presto")
save_simulation(sparse_sim)
